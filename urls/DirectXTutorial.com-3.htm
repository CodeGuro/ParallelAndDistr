<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>DirectXTutorial.com</title><link href="DirectXTutorial.com-3_files/Layout.css" rel="Stylesheet" type="text/css"><link href="DirectXTutorial.com-3_files/Black.css" rel="Stylesheet" type="text/css"><script src="DirectXTutorial.com-3_files/ga.js" async="" type="text/javascript"></script><script type="text/javascript" src="DirectXTutorial.com-3_files/dxpages.js" language="javascript"></script></head><body><a href="http://www.directxtutorial.com/default.aspx"><img src="DirectXTutorial.com-3_files/HeadLogo.png" alt="DirectXTutorial.com"></a><div class="logoscript">The Ultimate DirectX Tutorial</div><div class="logout">Signed in as 'tukun2'<br><a class="mainlink" href="http://www.directxtutorial.com/changeprofile.aspx">Change Profile</a> - <a class="mainlink" href="http://www.directxtutorial.com/signout.aspx?retloc=lesson.aspx&amp;lessonid=9-11-3">Sign Out</a></div><div class="sidebar"><div class="sidepanel"><div><b>Navigation</b><br><br><a class="sidelink" href="http://www.directxtutorial.com/default.aspx">Home</a><br><a class="sidelink" href="http://www.directxtutorial.com/LessonList.aspx?listid=111">DirectX for Windows 8</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=112">DirectX 11.2</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=111">DirectX 11.1</a><br><a class="sidelink" href="http://www.directxtutorial.com/LegacyList.aspx">DirectX for Desktop</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=11">DirectX 11</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=9">DirectX 9</a><br><a class="sidelink" href="http://www.directxtutorial.com/lessonarticle.aspx?id=2">Useful Resources</a><br><a class="sidelink" href="http://www.directxtutorial.com/lessonarticle.aspx?id=1">About DirectXTutorial</a><br><a class="sidelink" href="http://www.directxtutorial.com/TPremium.aspx">DirectXTutorial Premium</a><br><a class="sidelink" href="http://www.directxtutorial.com/testimonials.aspx">Testimonials</a><br></div></div><br><div class="sidepanel"><div><b>Contact</b><br><br>Contact me here:<br><span style="font-size:11px;">Twitter: <a class="mainlink" href="https://twitter.com/#%21/dastopher">@dastopher</a><br>Email: chris@directxtutorial.com<br></span><br>Or leave me feedback:<br><span style="font-size:11px;"><a href="" class="mainlink" onclick="RunFeedback(); return false;">Quick Feedback</a></span><br></div></div><br></div><div class="titlebar">Lesson 3: Sending Data</div><div class="entrybox"><div class="navbar"><div class="prevbar"><a class="mainlink" href="http://www.directxtutorial.com/Lesson.aspx?lessonid=9-11-2">Previous</a></div><div class="nextbar"><a class="mainlink" href="http://www.directxtutorial.com/Lesson.aspx?lessonid=9-11-4">Next</a></div></div><div class="entryheader" style="position:relative;">Lesson Overview</div><div class="maintext" style="position: relative;"><p>Now,
 the last lesson's program didn't actually do anything.  It started 
Winsock, checked to make sure it was done correctly, then closed it 
again.  This time we'll get some real action going.  We will be setting 
up a client application, then building a server to go with it.  </p></div><div class="entryheader" style="position:relative;">The Client</div><div class="maintext" style="position: relative;"><p>To
 start, let's take last lesson's code and update it with additional code
 that will complete the client.  This client will be a simple one.  All 
it will do is ask for text input, and send that text to a server.</p><p>There are a few steps to doing this:</p><p>1.  Declare some new constants and variables. <br>2.  Create the socket. <br>3.  Determine the IP address and port of the server application. <br>4.  Get a string and send the data. </p><hr><p class="subheader">1.  Declare some new constants and variables.</p><p style="padding-left:15px;">There are two new macros and three new variables we will need:</p><div class="codebox" style="left:15px;"><b>#define&nbsp;SERVER_ADDRESS&nbsp;"192.168.1.100"<br>#define&nbsp;SERVER_PORT&nbsp;17000</b><br><br>WSADATA&nbsp;Winsock;<br><b>SOCKET&nbsp;Socket;<br>sockaddr_in&nbsp;ServerAddress;<br>char&nbsp;Buffer[16];</b><br><br>void&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</div><p class="subheader" style="padding-left:15px;">#define SERVER_ADDRESS "192.168.1.100"</p><p style="padding-left:30px;">This is an arbitrary definition which allows us to easily change the IP address of the computer we will connect to.  For now, you should set this to your current local IP address.  192.168.1.100 is a common local IP for computers that are alone on their own network.</p><p class="subheader" style="padding-left:15px;">#define SERVER_PORT 17000</p><p style="padding-left:30px;">This is another aribitrary definition which determines the port for the remote application.  There isn't a remote application yet, as we haven't written one, but when we do, we'll be using 17000 as its port.</p><p class="subheader" style="padding-left:15px;">SOCKET Socket;</p><p style="padding-left:30px;">As discussed in Lesson 1, a socket is the interface through which an application communicates with another.  These are all managed by Windows, so generally you don't have to do anything but claim one.</p><p style="padding-left:30px;">A SOCKET is a 32-bit integer much like a handle, which stores the identity of the socket we will use.  We'll call a function later to fill it with value, so we'll leave it uninitialized for now.</p><p class="subheader" style="padding-left:15px;">sockaddr_in ServerAddress;</p><p style="padding-left:30px;">This is a struct that holds all the information used to locate a remote application.  It stands for Socket Address In.  We will go over the values of this struct later in this lesson as we come to them, as each member takes a little bit of explanation in itself.</p><p class="subheader" style="padding-left:15px;">char Buffer[16];</p><p style="padding-left:30px;">This is a buffer we will use to store the data we'll send.  Fairly simple.  Here, it has been set to 16 bytes of data. </p><hr><p class="subheader">2.  Create the Socket.</p><p style="padding-left:15px;">Before we can use the socket, we need to tell Windows to create the socket we want.  There is a simple function to do this: socket().  Calling this function returns the "handle" to the socket we will use.  This function has three parameters:</p><div class="codebox" style="left:15px;">SOCKET&nbsp;socket<br>(<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;af,<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;type,<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;protocol<br>);</div><p class="subheader" style="padding-left:15px;">int af,</p><p style="padding-left:30px;">This parameter contains the address family of the socket.  Exactly what an address family is, is uncertain.  When the concept of sockets was first formed, an address family was intended to be a specific type of address.  However, this has been somewhat confused.  In this matter, simplicity is futile.</p><p style="padding-left:30px;">All you need to know is that we use IPv4, and that the flag we need to put here is AF_INET.</p><p class="subheader" style="padding-left:15px;">int type,</p><p style="padding-left:30px;">In this parameter, we state the type of socket we want.  Remember there are three types: Datagram Sockets, Stream Sockets and Raw Sockets.  We want to use Datagram Sockets, which is specified with the SOCK_DGRAM flag.</p><p style="padding-left:30px;">The following table shows some of the other tags you can use in this parameter:</p><table class="tablebox" style="left:30px;"><tbody><tr><th width="150px">Value</th><th width="480px">Description</th></tr><tr><td>SOCK_DGRAM</td><td>This socket type supports the datagrams used by the User Datagram Protocol.  It can send data to any computer without notice.</td></tr><tr><td>SOCK_STREAM</td><td>This socket type supports TCP/IP.  It is a connection-based socket, which can only send data to a computer with which a connection has been established.</td></tr><tr><td>SOCK_RAW</td><td>This socket type gives the programmer access to the layer below UDP and TCP.  Datagram sockets and stream sockets both add headers to each packet. However, using raw sockets, a programmer can bypass these.</td></tr></tbody></table><p class="subheader" style="padding-left:15px;">int protocol,</p><p style="padding-left:30px;">In this parameter we specify which protocol we will use.  Common flags are IPPROTO_TCP and IPPROTO_UDP.  We obviously want the later.  Other flags can be used here but they are beyond the scope of this tutorial.</p><p style="padding-left:30px;">Now, why would we want to clarify the protocol again?  Well, we could leave this at 0 and the service provider would determine the protocol to use.  However, we definitely want to use UDP, so we need to specify it here.</p><p style="padding-left:30px;">Here is the function as it is written in real code:</p><div class="codebox" style="left:30px;">Socket&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_DGRAM,&nbsp;IPPROTO_UDP);</div><p style="padding-left:30px;">This initializes the Socket variable that we defined earlier.</p><hr><p class="subheader">3.  Determine the IP address and port of the server application.</p><p style="padding-left:15px;">In this step we need to initialize the ServerAddress struct we defined earlier.  This is somewhat simple, as there are only three members.  We need to give it the address family, the server's IP address, and the server's port.</p><p style="padding-left:15px;">Here is the code to do this:</p><div class="codebox" style="left:15px;">ZeroMemory(&amp;ServerAddress,&nbsp;sizeof(ServerAddress));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;struct<br>ServerAddress.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;address&nbsp;family<br>ServerAddress.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(SERVER_ADDRESS);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;IP&nbsp;address<br>ServerAddress.sin_port&nbsp;=&nbsp;SERVER_PORT;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;port</div><p style="padding-left:15px;">The comments explain it fairly well, but let's run over it quickly.</p><p style="padding-left:15px;">First things first.  Always initialize the struct.  For this we use the ZeroMemory() function.</p><p style="padding-left:15px;">Next, we respecify that we are using the AF_INET address family.</p><p style="padding-left:15px;">The third line is slightly more complex.  The actual address resides in a member of sin_addr, not in sin_addr itself.  Notice also that we call the function inet_addr() to convert the string SERVER_ADDRESS into an actual address that can be understood.</p><p style="padding-left:15px;">Finally, we set the port we will contact.  Remember that the client does not need to claim a port, so this is the <i>server's</i> port.  Windows will assign the client application a port automatically so the server can send messages back (but I get ahead of myself).</p><hr><p class="subheader">4.  Get a string and send the data.</p><p style="padding-left:15px;">Now we are ready for the actual program!  We've got everything set up, now we need to collect some data and send it.  Once we've done that, we need to wait for the server to reply.</p><div class="codebox" style="left:15px;">while(true)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;get&nbsp;some&nbsp;text<br>&nbsp;&nbsp;&nbsp;&nbsp;gets(Buffer);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;send&nbsp;the&nbsp;data<br>&nbsp;&nbsp;&nbsp;&nbsp;sendto(Socket,&nbsp;Buffer,&nbsp;16,&nbsp;0,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(sockaddr));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;if&nbsp;the&nbsp;message&nbsp;started&nbsp;with&nbsp;a&nbsp;space,&nbsp;quit<br>&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;'&nbsp;')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>}</div><p style="padding-left:15px;">Let's go over this code.</p><p style="padding-left:15px;">The whole thing is stuck in an infinite loop, created by a while(true).  This way, we can send and receive multiple messages.</p><p style="padding-left:15px;">The first step in the loop is to get a message to send.  The gets() function gets input from the user and places it into a character array.  We will use Buffer (as defined in step one) for this.  Note: the gets() funtion is available in the stdio.h header file.</p><p style="padding-left:15px;">The next function has a few parameters to cover.  It's not necessarily simple, so take it slow.  It is the sendto() function, and it sends a message to the remote computer.  Here is the prototype:</p><div class="codebox" style="left:15px;">int&nbsp;sendto(SOCKET&nbsp;s,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;SOCKET&nbsp;we&nbsp;created&nbsp;earlier<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char*&nbsp;buf,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;buffer&nbsp;of&nbsp;the&nbsp;data&nbsp;we&nbsp;want&nbsp;to&nbsp;send<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;length&nbsp;of&nbsp;that&nbsp;data<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;flags,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;some&nbsp;flags<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sockaddr*&nbsp;to,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;address&nbsp;of&nbsp;where&nbsp;the&nbsp;data&nbsp;should&nbsp;be&nbsp;sent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;tolen);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;address</div><p style="padding-left:15px;">These aren't all obvious, so let's go over them.</p><p class="subheader" style="padding-left:15px;">SOCKET s,</p><p style="padding-left:30px;">This is simply the "handle" of the socket.  We put this number into the variable Socket, so we should use that for this parameter.</p><p class="subheader" style="padding-left:15px;">char* buf,</p><p style="padding-left:30px;">This parameter is a pointer to the data we want to send.  Because putting Buffer counts as a pointer to Buffer[0], this will work just fine for us.</p><p class="subheader" style="padding-left:15px;">int len,</p><p style="padding-left:30px;">This parameter is the length of the data to be sent.  We'll set it to 16, as that is as big as our character buffer.</p><p style="padding-left:30px;">Important:  Getting this parameter wrong can open up to dangerous security issues.  See the lesson on security for more information.  For now, just don't set the length any higher than the size of the character array.</p><p class="subheader" style="padding-left:15px;">int flags,</p><p style="padding-left:30px;">Here we put flags.  The only flags available here are beyond the scope of the tutorial, but they can control some low-level functionality of how data gets sent.  For all intents and purposes, you can set it to 0 and leave it at that.</p><p class="subheader" style="padding-left:15px;">sockaddr* to,</p><p style="padding-left:30px;">This is new.  Here we have a pointer to a sockaddr struct.  This struct contains the data necessary to locate the remote application to send the data to.  This consists of the address family, the IP address and the port.</p><p style="padding-left:30px;">Wait...don't we have one of those already?  The sockaddr_in struct contains the exact same values.  Why sockaddr?</p><p style="padding-left:30px;">The sockaddr struct is identical to the sockaddr_in struct in terms of its binary content.  The only difference is how you access the values.  Here are the two definitions so we can compare them:</p><div class="codebox" style="left:30px;">struct&nbsp;sockaddr_in<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;sin_family;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;address&nbsp;family<br>&nbsp;&nbsp;&nbsp;&nbsp;u_short&nbsp;sin_port;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;port<br>&nbsp;&nbsp;&nbsp;&nbsp;in_addr&nbsp;sin_addr;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;ip&nbsp;address<br>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;sin_zero[8];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;bunch&nbsp;of&nbsp;zeroes&nbsp;for&nbsp;internal&nbsp;purposes<br>};</div><p></p><div class="codebox" style="left:30px;">struct&nbsp;sockaddr<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;ushort&nbsp;sa_family;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;address&nbsp;family<br>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;sa_data[14];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;data...mushed&nbsp;into&nbsp;one&nbsp;char&nbsp;array<br>}</div><p style="padding-left:30px;">As you can see, sockaddr has one variable name for the port and IP address (and the empty space) while sockaddr_in has three.  This is because the Winsock library extracts the data by accessing a char array, and so by default uses a sockaddr.  However, because it is hard to plug values into this, the virtually identical sockaddr_in is provided for you to plug the values in instead.</p><p style="padding-left:30px;">Thus, we have a sockaddr_in and a parameter which is a sockaddr*.  We therefore take the address of the sockaddr_in and cast into an address of a sockaddr, as is bolded below:</p><div class="codebox" style="left:30px;">sendto(Socket,&nbsp;Buffer,&nbsp;16,&nbsp;0,&nbsp;<b>(sockaddr*)&amp;ServerAddress</b>,&nbsp;ServerLen);</div><p style="padding-left:30px;">As you can see, &amp;ServerAddress was casted into a sockaddr*.</p><p class="subheader" style="padding-left:15px;">int tolen</p><p style="padding-left:30px;">This last parameter is an integer specifying the size of the sockaddr, in bytes.  Why do this?  Mainly because different address families have different sized addresses, so the struct size can vary.  However, it won't for us.  For this parameter, we'll just put sizeof(sockaddr), the size we are using, and leave it at that.</p><p style="padding-left:30px;">Let's take a look at the function as a whole, as it will be written:</p><div class="codebox" style="left:30px;">sendto(Socket,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;socket&nbsp;we're&nbsp;sending&nbsp;data&nbsp;on<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Buffer,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;data&nbsp;to&nbsp;send<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;data<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;flags<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;where&nbsp;to&nbsp;send&nbsp;the&nbsp;data<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServerLen);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;address</div><p style="padding-left:30px;">or in shorter form:</p><div class="codebox" style="left:30px;">sendto(Socket,&nbsp;Buffer,&nbsp;16,&nbsp;0,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(sockaddr));</div><p style="padding-left:15px;">Now let's take a look at the whole client application: </p><hr><p class="subheader">The Completed Client Code</p><p style="padding-left:15px;">Below is the client code.  The parts in bold are the changes from last lesson's program.</p><div class="codebox" style="left:15px;">#define&nbsp;_WINSOCKAPI_&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Don't&nbsp;include&nbsp;Winsock.h<br>#include&nbsp;&lt;winsock2.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;WinSock&nbsp;header&nbsp;file<br><b>#include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input/Output&nbsp;header&nbsp;file&nbsp;for&nbsp;gets()&nbsp;function</b><br><br>#pragma&nbsp;comment(lib,&nbsp;"Ws2_32.lib")&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;WinSock&nbsp;Library<br><br><b>#define&nbsp;SERVER_ADDRESS&nbsp;"192.168.1.100"<br>#define&nbsp;SERVER_PORT&nbsp;17000</b><br><br>WSADATA&nbsp;Winsock;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Stores&nbsp;information&nbsp;about&nbsp;Winsock<br><b>SOCKET&nbsp;Socket;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;ID&nbsp;of&nbsp;the&nbsp;socket<br>sockaddr_in&nbsp;ServerAddress;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;address&nbsp;to&nbsp;send&nbsp;data&nbsp;to<br>char&nbsp;Buffer[16];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;buffer&nbsp;of&nbsp;data&nbsp;to&nbsp;send</b><br><br>void&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;Winsock);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Start&nbsp;Winsock<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(LOBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2&nbsp;||&nbsp;HIBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;version<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<b>//&nbsp;Make&nbsp;the&nbsp;Socket<br>&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_DGRAM,&nbsp;IPPROTO_UDP);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input&nbsp;Server&nbsp;Information<br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;ServerAddress,&nbsp;sizeof(ServerAddress));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;struct<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;address&nbsp;family<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(SERVER_ADDRESS);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;IP&nbsp;address<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_port&nbsp;=&nbsp;SERVER_PORT;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;port<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Send&nbsp;the&nbsp;Messages<br>&nbsp;&nbsp;&nbsp;&nbsp;while(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gets(Buffer);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendto(Socket,&nbsp;Buffer,&nbsp;16,&nbsp;0,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(sockaddr));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;'&nbsp;')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</b><br><br>&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Close&nbsp;Winsock&nbsp;before&nbsp;exiting<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return;<br>}</div><p style="padding-left:15px;">Woohoo!  Now let's build the server to go with it!  </p></div><div class="entryheader" style="position:relative;">The Server</div><div class="maintext" style="position: relative;"><p>Now that we have a client application, it needs a server application.  The client itself doesn't do anything but send messages.  Therefore, let's build a server that can receive those messages and display them.</p><p>Our server program will be essentially the same program, with a few changes.  Naturally, this program will receive messages instead of sending them.  A couple of other things need tweaking.</p><p>1.  Declare some new variables. <br>2.  Bind the port to the socket. <br>3.  Rewrite the infinite loop to receive incoming messages.</p><hr><p class="subheader">1.  Declare some new variables.</p><p style="padding-left:15px;">We'll only need to new variables.  In addition to having a sockaddr_in for the server, we will need one for the client as well.  Also, the function that receives data needs a variable containing the size of the client's address.  Our new code (as altered from the client application) looks like this:</p><div class="codebox" style="left:15px;">WSADATA&nbsp;Winsock;<br>SOCKET&nbsp;Socket;<br>sockaddr_in&nbsp;ServerAddress;<br><b>sockaddr_in&nbsp;IncomingAddress;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;client's&nbsp;address</b><br>char&nbsp;Buffer[16];<br><b>int&nbsp;AddressLen&nbsp;=&nbsp;sizeof(IncomingAddress);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;client's&nbsp;address</b></div><p style="padding-left:15px;">As we go, we'll explain the use of each of these variables more specifically.</p><hr><p class="subheader">2.  Bind the port to the socket.</p><p style="padding-left:15px;">Binding is an action which forces our socket to act on a specific port.  In the case of our server, we need to tell it that we are using port 17000.  To not do this makes the server receive random data, which will confuse your program.</p><p style="padding-left:15px;">To force Winsock to listen on the correct port, we need to call the bind() function.  It's a simple function:</p><div class="codebox" style="left:15px;">int&nbsp;bind(SOCKET&nbsp;s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sockaddr*&nbsp;name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;namelen);</div><p style="padding-left:15px;">The first parameter is the socket we want to use.  We only have one, so we'll use that.</p><p style="padding-left:15px;">The second parameter is a pointer to an address struct.  In this struct we only need the address family (AF_INET) and the port number (17000).  We don't need the IP address because the computer is listening for data, and it doesn't need to know its own address to do that.  The data simply arrives.</p><p style="padding-left:15px;">The last parameter is the length of the address.  A sizeof() will do here.</p><p style="padding-left:15px;">This function, in practice, comes out like this:</p><div class="codebox" style="left:15px;">bind(Socket,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(ServerAddress));</div><p style="padding-left:15px;">Of course, we need to initialize ServerAddress, so:</p><div class="codebox" style="left:15px;">ZeroMemory(&amp;ServerAddress,&nbsp;sizeof(ServerAddress));<br>ServerAddress.sin_family&nbsp;=&nbsp;AF_INET;<br><b>//ServerAddress.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(SERVER_ADDRESS);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;no&nbsp;longer&nbsp;needed</b><br>ServerAddress.sin_port&nbsp;=&nbsp;SERVER_PORT;<br><b>bind(Socket,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(ServerAddress));</b></div><p style="padding-left:15px;">Again, the <b>bold</b> parts are the changes from the client program. </p><hr><p class="subheader">3.  Rewrite the infinite loop to receive incoming messages.</p><p style="padding-left:15px;">Here is where we actually get the data coming from the client.  The function we use to do this is recvfrom().  This one is easy, because its parameters are almost identical to the sendto() function.  Let's take a look at the prototype:</p><div class="codebox" style="left:15px;">int&nbsp;recvfrom(SOCKET&nbsp;s,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;SOCKET&nbsp;we&nbsp;created&nbsp;earlier<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char*&nbsp;buf,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;buffer&nbsp;where&nbsp;the&nbsp;data&nbsp;will&nbsp;be&nbsp;stored<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;limit&nbsp;of&nbsp;data&nbsp;to&nbsp;read<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;flags,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;some&nbsp;flags<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sockaddr*&nbsp;from,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;address&nbsp;of&nbsp;where&nbsp;the&nbsp;data&nbsp;came&nbsp;from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int*&nbsp;fromlen);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;length&nbsp;of&nbsp;that&nbsp;address</div><p style="padding-left:15px;">As you can see, these are very similar.  Only the last two really change.  Parameter five is now from instead of to, and parameter six (the last one) is now a pointer to an integer.</p><p style="padding-left:15px;">However, what all these parameters do is different.</p><p style="padding-left:15px;">The first is still the socket.  We only have one socket, so we will use it.</p><p style="padding-left:15px;">The second is the pointer to a buffer.  This points to where the incoming data will be stored.</p><p style="padding-left:15px;">Third is the length of the data.  For example, if you put 16 here, the function will only listen for 16 bytes of data, after which any additional data that was sent will be ignored.</p><p style="padding-left:15px;">Next are some flags.  There are some useful ones here, but we won't be covering them, as they are not necessary for anything we will do in this tutorial.  Check the MSDN for more information.</p><p style="padding-left:15px;">The fifth parameter is a pointer to a sockaddr struct.  When you call the function, this struct gets filled with the client's address and port, allowing you to send a reply.  We will do this in the next lesson.  For now, we will use the IncomingAddress struct we created in step 1.</p><p style="padding-left:15px;">Last, there is the length of the client address.  This is given as a pointer to an integer.  We created an integer just for this in step 1 called AddressLen.  Therefore, all we have to do is put the pointer to that variable in this parameter.</p><p style="padding-left:15px;">Here is how the function appears in your code:</p><div class="codebox" style="left:15px;">recvfrom(Socket,&nbsp;Buffer,&nbsp;16,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen)</div><p style="padding-left:15px;">and with the whole loop:</p><div class="codebox" style="left:15px;">while(true)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>if(recvfrom(Socket,&nbsp;Buffer,&nbsp;16,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))</b><br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Buffer[15]&nbsp;=&nbsp;'\0';&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;end&nbsp;the&nbsp;string&nbsp;with&nbsp;a&nbsp;\0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Received:&nbsp;%s\n",&nbsp;Buffer);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;show&nbsp;the&nbsp;data&nbsp;on&nbsp;the&nbsp;screen</b><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;'&nbsp;')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</div><p style="padding-left:15px;">As you can see here, the recvfrom() function is contain in an if() statement.  This is because the function returns 0 if there is no message, thus continuing the loop.</p><p style="padding-left:15px;">Also, you may notice that before the program places the text on the screen, we change the last value of the buffer to '\0'.  This is to keep printf() from displaying endless text.  It will continue showing text until it hits a '\0', so putting this at the end keeps this from happening.</p><p style="padding-left:15px;">In addition to this, forgetting the '\0' can open up to security issues (see Lesson 6 for more info). </p><hr><p class="subheader">The Completed Server Code</p><p style="padding-left:15px;">Now let's look at the whole server program.  The updates in <b>bold</b> are changes from the client, not from the last lesson.</p><div class="codebox" style="left:15px;">#define&nbsp;_WINSOCKAPI_&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Don't&nbsp;include&nbsp;Winsock.h<br>#include&nbsp;&lt;winsock2.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;WinSock&nbsp;header&nbsp;file<br><b>#include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input/Output&nbsp;header&nbsp;file&nbsp;for&nbsp;gets()&nbsp;function</b><br><br>#pragma&nbsp;comment(lib,&nbsp;"Ws2_32.lib")&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;WinSock&nbsp;Library<br><br><b>//#define&nbsp;SERVER_ADDRESS&nbsp;"192.168.1.100"&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;no&nbsp;longer&nbsp;needed</b><br>#define&nbsp;SERVER_PORT&nbsp;17000<br><br>WSADATA&nbsp;Winsock;<br>SOCKET&nbsp;Socket;<br>sockaddr_in&nbsp;ServerAddress;<br><b>sockaddr_in&nbsp;IncomingAddress;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;client's&nbsp;address</b><br>char&nbsp;Buffer[16];<br><b>int&nbsp;AddressLen&nbsp;=&nbsp;sizeof(IncomingAddress);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;client's&nbsp;address</b><br><br>void&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;Winsock);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Start&nbsp;Winsock<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(LOBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2&nbsp;||&nbsp;HIBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;version<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Make&nbsp;the&nbsp;Socket<br>&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_DGRAM,&nbsp;IPPROTO_UDP);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input&nbsp;server&nbsp;information&nbsp;and&nbsp;bind&nbsp;it&nbsp;to&nbsp;the&nbsp;socket<br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;ServerAddress,&nbsp;sizeof(ServerAddress));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;struct<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;address&nbsp;family<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>//ServerAddress.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(SERVER_ADDRESS);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;no&nbsp;longer&nbsp;needed</b><br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_port&nbsp;=&nbsp;SERVER_PORT;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;port<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>bind(Socket,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(ServerAddress));</b><br><br>&nbsp;&nbsp;&nbsp;&nbsp;while(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if(recvfrom(Socket,&nbsp;Buffer,&nbsp;16,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Buffer[15]&nbsp;=&nbsp;'\0';&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;end&nbsp;the&nbsp;string&nbsp;with&nbsp;a&nbsp;\0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Received:&nbsp;%s\n",&nbsp;Buffer);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;show&nbsp;the&nbsp;data&nbsp;on&nbsp;the&nbsp;screen</b><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;'&nbsp;')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Close&nbsp;Winsock&nbsp;before&nbsp;exiting<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return;<br>}</div><p style="padding-left:15px;">If you run these two programs, you get an actual client-server setup!</p><center><img alt="Server.exe and Client.exe" src="DirectXTutorial.com-3_files/1.png" height="617" width="629"><br><br>Server.exe and Client.exe</center><p style="padding-left:15px;">Note: when you build your programs, realize that these are two separate .exe files created by two separate projects.  I've named these two server.exe and client.exe for simplicity.</p><p style="padding-left:15px;">Another note: beware of firewalls.  These things get really pesky when doing network programming.  I suggest becoming familiar with all your security settings for all your network hardware and software firewalls.  Sometimes these things will block activity without even telling you, and that can frequently be the problem.  </p></div><div class="entryheader" style="position:relative;">Summary</div><div class="maintext" style="position: relative;"><p>Now this is more like it!  An actual networked application!</p><p>This is really just a simple pair of programs to send data to one another.  Next lesson we'll get into building a real chat program that is capable of much more.  For now, try these exercises so you don't get overwhelmed next lesson.</p><p>1. Extend the length of the text so you don't keep getting cut off. <br>2. Find your internet IP address and use it instead of your local IP address. <br>3. Figure out how to get through any firewalls you run into. <br>4. Find a frequently unused port on Wikipedia and use that instead of 17000. <br>5. Find out what happens if you don't set the last char of the buffer to '\0'. <br>6. Make the server send the data back to the client, and have the client print it on the screen too.</p><p>When you're done, let's apply your coding skills to build a real chat program.</p><center><p>Next Lesson: A Simple Chat Server</p><p><a class="mainlink" href="http://www.directxtutorial.com/Lesson.aspx?lessonid=9-11-4">GO! GO! GO!</a></p></center></div><center><div class="copyright"> © 2006-2016 DirectXTutorial.com. All Rights Reserved. <a href="" onclick="RunLegal(); return false;" class="availablelink">Expand</a></div></center></div><script type="text/javascript">var _gaq = _gaq || [];_gaq.push(['_setAccount', 'UA-476839-2']);_gaq.push(['_trackPageview']);(function() {var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></body></html>