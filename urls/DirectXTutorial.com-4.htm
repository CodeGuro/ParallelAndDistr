<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>DirectXTutorial.com</title><link href="DirectXTutorial.com-4_files/Layout.css" rel="Stylesheet" type="text/css"><link href="DirectXTutorial.com-4_files/Black.css" rel="Stylesheet" type="text/css"><script src="DirectXTutorial.com-4_files/ga.js" async="" type="text/javascript"></script><script type="text/javascript" src="DirectXTutorial.com-4_files/dxpages.js" language="javascript"></script></head><body><a href="http://www.directxtutorial.com/default.aspx"><img src="DirectXTutorial.com-4_files/HeadLogo.png" alt="DirectXTutorial.com"></a><div class="logoscript">The Ultimate DirectX Tutorial</div><div class="logout">Signed in as 'tukun2'<br><a class="mainlink" href="http://www.directxtutorial.com/changeprofile.aspx">Change Profile</a> - <a class="mainlink" href="http://www.directxtutorial.com/signout.aspx?retloc=lesson.aspx&amp;lessonid=9-11-4">Sign Out</a></div><div class="sidebar"><div class="sidepanel"><div><b>Navigation</b><br><br><a class="sidelink" href="http://www.directxtutorial.com/default.aspx">Home</a><br><a class="sidelink" href="http://www.directxtutorial.com/LessonList.aspx?listid=111">DirectX for Windows 8</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=112">DirectX 11.2</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=111">DirectX 11.1</a><br><a class="sidelink" href="http://www.directxtutorial.com/LegacyList.aspx">DirectX for Desktop</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=11">DirectX 11</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=9">DirectX 9</a><br><a class="sidelink" href="http://www.directxtutorial.com/lessonarticle.aspx?id=2">Useful Resources</a><br><a class="sidelink" href="http://www.directxtutorial.com/lessonarticle.aspx?id=1">About DirectXTutorial</a><br><a class="sidelink" href="http://www.directxtutorial.com/TPremium.aspx">DirectXTutorial Premium</a><br><a class="sidelink" href="http://www.directxtutorial.com/testimonials.aspx">Testimonials</a><br></div></div><br><div class="sidepanel"><div><b>Contact</b><br><br>Contact me here:<br><span style="font-size:11px;">Twitter: <a class="mainlink" href="https://twitter.com/#%21/dastopher">@dastopher</a><br>Email: chris@directxtutorial.com<br></span><br>Or leave me feedback:<br><span style="font-size:11px;"><a href="" class="mainlink" onclick="RunFeedback(); return false;">Quick Feedback</a></span><br></div></div><br></div><div class="titlebar">Lesson 4: A Simple Chat Server</div><div class="entrybox"><div class="navbar"><div class="prevbar"><a class="mainlink" href="http://www.directxtutorial.com/Lesson.aspx?lessonid=9-11-3">Previous</a></div><div class="nextbar"><a class="mainlink" href="http://www.directxtutorial.com/Lesson.aspx?lessonid=9-11-5">Next</a></div></div><div class="entryheader" style="position:relative;">Lesson Overview</div><div class="maintext" style="position: relative;"><p>Unfortunately,
 knowing how to send and receive raw data is not enough.  There are a 
lot of issues that complicate the matter, and unless you know what to 
do, these will be quite the stumbling block.</p><p>For instance, the 
server for a chat program has to send messages to many different 
computers usually, not just one.  This means that our server needs to 
know when clients connect and disconnect, and keep track of who is still
 there, as well as what their IP addresses are.</p><p>After we've covered some theory, we'll take a look at the client and server for the simple chat program.</p><p>Well, we have a big agenda.  Let's get to it.  </p></div><div class="entryheader" style="position:relative;">Synchronizing Connected Clients</div><div class="maintext" style="position: relative;"><p>The
 next topic we have to take up is how we are going to get the server to 
work with multiple clients.  This is a fairly simple issue, assuming 
that you've got a good understanding of what the problem is.</p><p>There
 are two basic problems here.  First, how do you determine which 
messages were sent from legitimate clients and which messages were 
hoaxes sent from elsewhere.  Second, how do you know what computers to 
send your messages to.</p><p>In this chat program, the server will 
accept a message from any connected client, then broadcast the data out 
to all clients who have connected to the server.</p><center><img alt="Message Broadcasting" src="DirectXTutorial.com-4_files/1.gif" height="419" width="552"><br><br>Message Broadcasting</center><p>Fortunately,
 this is mostly just a matter of data management.  All you really need 
to do is only send messages coming from connected clients, and only send
 them to connected clients.</p><p>This begs the question: if the clients
 can just send any data to the server they want from the start, how does
 the client actually connect and get into the "chatroom"?  The answer is
 to <i>knock</i>.</p><hr><p class="subheader">Knocking</p><p style="padding-left:15px;">A
 knock is a rather simple packet sent from a client, that tells the 
server all about itself.  It usually contains information such as a 
username or password.  It also contains some unique set of bytes which 
the client and server both use to make sure the message is actually 
coming from a client.</p><p style="padding-left:15px;">The server takes this packet, extracts the needed information, and logs the client's IP address in its log of connected clients.</p><center><img alt="Knocking in Action" src="DirectXTutorial.com-4_files/2.png" height="248" width="633"><br><br>Knocking in Action</center><p style="padding-left:15px;">Once
 this is done, the server knows which clients should receive the 
messages.  When broadcasting a message, it simply reads through its log 
and sends the message to each IP address it finds.</p><hr><p class="subheader">Disconnecting</p><p style="padding-left:15px;">Once
 a client has stopped participating in the chat, it must send a 
disconnect message.  If it doesn't, the server will go on sending 
messages to it forever.</p><p style="padding-left:15px;">The disconnect 
message is similar to the knock.  It contains a few bytes that tell the 
server that it is a disconnect message, as well as some additional data.
  The server can then remove the client from its log.  This is called a 
clean disconnection.</p><p style="padding-left:15px;">Of course, if the 
client's network connection is closed before the client has a chance to 
send its message, then the server has no idea what happened.  We won't 
cover that in this lesson, as its solution is much simpler when using 
not using a Console Application.  We'll cover it in the next lesson.  </p></div><div class="entryheader" style="position:relative;">The Client</div><div class="maintext" style="position: relative;"><p>We'll
 start with the client-side of our chat program.  We will run it in a 
console for simplicity (you can add it to whatever interface you want, 
Windows or DirectX).  Keep in mind that this is a simple chat program.  A
 lot of security issues and bugs have not necessarily been accounted for
 (and there will be quite a few in such a project).</p><p>We'll start by taking the client program from the last lesson and modifying it slightly by adding a few things.</p><p>1.  Add a few new variables. <br>2.  Add code that sends a knock to the server. <br>3.  Add code that receives messages while the user is typing.</p><p>It's really that simple. </p><hr><p class="subheader">1.  Add a few new variables.</p><p style="padding-left:15px;">We'll
 need two.  We'll need a new data buffer (one for sending data and one 
for receiving data).  We'll also need an integer to store the size of an
 address (as we'll be using the recvfrom() function).</p><p style="padding-left:15px;">We'll also up the buffer size to 256, so we can send longer messages.</p><p style="padding-left:15px;">The new code is:</p><div class="codebox" style="left:15px;">WSADATA&nbsp;Winsock;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Stores&nbsp;information&nbsp;about&nbsp;Winsock<br>SOCKET&nbsp;Socket;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;ID&nbsp;of&nbsp;the&nbsp;socket<br>sockaddr_in&nbsp;ServerAddress;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;address&nbsp;to&nbsp;send&nbsp;data&nbsp;to<br>char&nbsp;<b>SendBuffer[256];</b>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;buffer&nbsp;of&nbsp;data&nbsp;to&nbsp;send<br><b>char&nbsp;RecvBuffer[256];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;buffer&nbsp;of&nbsp;data&nbsp;to&nbsp;receive<br>int&nbsp;SizeInt&nbsp;=&nbsp;sizeof(ServerAddress);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;size&nbsp;of&nbsp;the&nbsp;server's&nbsp;address</b></div><p style="padding-left:15px;">And that's all.  We'll go over these in detail as we come to them. </p><hr><p class="subheader">2.  Add code that sends a knock to the server.</p><p style="padding-left:15px;">For our simple chat program, we'll use a simple knock.  We'll simply send a single byte with a byte value of 1.  If we receive this, we'll assume that another client is trying to join.</p><p style="padding-left:15px;">Note that we are not sending a "1".  That would be confusing if the user ever actually typed this.  The message "1" actually has a value of 49.  We're sending a 1, not a "1".</p><p style="padding-left:15px;">Here is the simple code we have to add:</p><div class="codebox" style="left:15px;">SendBuffer[0]&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;prepare&nbsp;a&nbsp;knock&nbsp;in&nbsp;the&nbsp;buffer<br>sendto(Socket,&nbsp;SendBuffer,&nbsp;1,&nbsp;0,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(sockaddr));</div><p style="padding-left:15px;">In the first line of code, we are manually setting the first byte of the sending buffer to 1.  When the server gets this, it will know we are trying to connect.</p><p style="padding-left:15px;">The second line of code sends the buffer to the server.  Note that only one byte is sent (the third parameter).</p><p style="padding-left:15px;">Look at the full program below to see how this fits in the program. </p><hr><p class="subheader">3.  Add code that receives messages while the user is typing.</p><p style="padding-left:15px;">This is the hardest step, but that's not saying much.</p><p style="padding-left:15px;">This step really has two sub-parts.  The first is the command to start the receiving thread, and the second is the function we'll use as the thread.</p><p style="padding-left:15px;">The first is just as we went over above in the first section:</p><div class="codebox" style="left:15px;">CreateThread(NULL,&nbsp;0,&nbsp;RecvThread,&nbsp;NULL,&nbsp;0,&nbsp;NULL);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Start&nbsp;the&nbsp;receiver&nbsp;thread</div><p style="padding-left:15px;">As it's mostly NULLs and 0s, there isn't much to talk about here.</p><p style="padding-left:15px;">The second part is the RecvThread() function.</p><p style="padding-left:15px;">It's simple.  It's basically just a loop that waits for messages using recvfrom(), writes them to the screen, and waits again.</p><div class="codebox" style="left:15px;">DWORD&nbsp;WINAPI&nbsp;RecvThread(LPVOID&nbsp;Whatever)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;while(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Wait&nbsp;for&nbsp;messages&nbsp;to&nbsp;arrive<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvfrom(Socket,&nbsp;RecvBuffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;&amp;SizeInt);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Print&nbsp;them&nbsp;to&nbsp;the&nbsp;screen<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Received:&nbsp;");&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;print&nbsp;a&nbsp;pretty&nbsp;"Received:&nbsp;"&nbsp;label<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(RecvBuffer);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;print&nbsp;the&nbsp;data&nbsp;itself<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;jump&nbsp;to&nbsp;a&nbsp;new&nbsp;line<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;the&nbsp;user&nbsp;quits,&nbsp;this&nbsp;thread&nbsp;has&nbsp;to&nbsp;exit&nbsp;too,&nbsp;or&nbsp;the&nbsp;program&nbsp;won't&nbsp;end<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(SendBuffer[0]&nbsp;==&nbsp;'&nbsp;');<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>}</div><p style="padding-left:15px;">The function only has three parts inside the loop.  One to wait for messages, one to print the messages, and one to quit when the spacebar is the first character.</p><p style="padding-left:15px;">Notice that the last part where it breaks from the loop, is in this function, but it is also in the main() function.  This is because the program will continue until all threads have finished.  Because this thread uses an infinite loop, we need to provide for a way out. </p><hr><p class="subheader">The Whole Client</p><p style="padding-left:15px;">The client is a fairly simple program.  You won't be able to run it really until you've built the server, but here's the code for it:</p><div class="codebox" style="left:15px;">#define&nbsp;_WINSOCKAPI_&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Don't&nbsp;include&nbsp;Winsock.h<br>#include&nbsp;&lt;winsock2.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;WinSock&nbsp;header&nbsp;file<br>#include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input/Output&nbsp;header&nbsp;file&nbsp;for&nbsp;gets()&nbsp;function<br><br>#pragma&nbsp;comment(lib,&nbsp;"Ws2_32.lib")&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;WinSock&nbsp;Library<br><br>#define&nbsp;SERVER_ADDRESS&nbsp;"192.168.1.100"<br>#define&nbsp;SERVER_PORT&nbsp;17000<br><br><b>DWORD&nbsp;WINAPI&nbsp;RecvThread(LPVOID&nbsp;Whatever);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;RecvThread()&nbsp;prototype</b><br><br>WSADATA&nbsp;Winsock;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Stores&nbsp;information&nbsp;about&nbsp;Winsock<br>SOCKET&nbsp;Socket;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;ID&nbsp;of&nbsp;the&nbsp;socket<br>sockaddr_in&nbsp;ServerAddress;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;address&nbsp;to&nbsp;send&nbsp;data&nbsp;to<br>char&nbsp;<b>SendBuffer[256];</b>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;buffer&nbsp;of&nbsp;data&nbsp;to&nbsp;send<br><b>char&nbsp;RecvBuffer[256];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;buffer&nbsp;of&nbsp;data&nbsp;to&nbsp;receive<br>int&nbsp;SizeInt&nbsp;=&nbsp;sizeof(ServerAddress);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;size&nbsp;of&nbsp;the&nbsp;server's&nbsp;address</b><br><br>void&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;Winsock);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(LOBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2&nbsp;||&nbsp;HIBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;version<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Make&nbsp;the&nbsp;Socket<br>&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_DGRAM,&nbsp;IPPROTO_UDP);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input&nbsp;Server&nbsp;Information<br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;ServerAddress,&nbsp;sizeof(ServerAddress));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;struct<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;address&nbsp;family<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(SERVER_ADDRESS);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;IP&nbsp;address<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_port&nbsp;=&nbsp;SERVER_PORT;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;port<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<b>//&nbsp;Send&nbsp;a&nbsp;knock&nbsp;to&nbsp;the&nbsp;server<br>&nbsp;&nbsp;&nbsp;&nbsp;SendBuffer[0]&nbsp;=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;sendto(Socket,&nbsp;SendBuffer,&nbsp;1,&nbsp;0,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(sockaddr));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Start&nbsp;the&nbsp;receiver&nbsp;thread<br>&nbsp;&nbsp;&nbsp;&nbsp;CreateThread(NULL,&nbsp;0,&nbsp;RecvThread,&nbsp;NULL,&nbsp;0,&nbsp;NULL);</b><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Send&nbsp;the&nbsp;Messages<br>&nbsp;&nbsp;&nbsp;&nbsp;while(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gets(<b>SendBuffer</b>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendto(Socket,&nbsp;<b>SendBuffer,&nbsp;256</b>,&nbsp;0,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(sockaddr));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(<b>SendBuffer[0]</b>&nbsp;==&nbsp;'&nbsp;')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return;<br>}<br><br><b>DWORD&nbsp;WINAPI&nbsp;RecvThread(LPVOID&nbsp;Whatever)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;while(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Wait&nbsp;for&nbsp;messages&nbsp;to&nbsp;arrive<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvfrom(Socket,&nbsp;RecvBuffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;&amp;SizeInt);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Print&nbsp;them&nbsp;to&nbsp;the&nbsp;screen<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Received:&nbsp;");&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;print&nbsp;a&nbsp;pretty&nbsp;"Received:&nbsp;"&nbsp;label<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(RecvBuffer);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;print&nbsp;the&nbsp;data&nbsp;itself<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;jump&nbsp;to&nbsp;a&nbsp;new&nbsp;line<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;the&nbsp;user&nbsp;quits,&nbsp;this&nbsp;thread&nbsp;has&nbsp;to&nbsp;exit&nbsp;too,&nbsp;or&nbsp;the&nbsp;program&nbsp;won't&nbsp;end<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(SendBuffer[0]&nbsp;==&nbsp;'&nbsp;')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>}</b></div><p style="padding-left:15px;">Next, we'll talk about the server and how it works with our new client.  </p></div><div class="entryheader" style="position:relative;">The Server</div><div class="maintext" style="position: relative;"><p>Our server will be a bit more complex.  It follows a fairly simple pattern, though.  It simply waits for messages, then broadcasts them.  There are certain exceptions though, such as data that did not come from one of the connected clients, or clients that are knocking.</p><p>There are four major additions we need to make to the server we used in Lesson 3:</p><p>1.  Add an array of sockaddr_in to store all the client addresses. <br>2.  Have the main loop check each function to see if it is a knock. <br>3.  Broadcast any messages to all connected clients. <br>4.  Detect when a client is leaving, and clear his address from the array. </p><hr><p class="subheader">1.  Add an array of sockaddr_in to store all the client addresses.</p><p style="padding-left:15px;">This is really a one-liner, so:</p><div class="codebox" style="left:15px;">WSADATA&nbsp;Winsock;<br>SOCKET&nbsp;Socket;<br>sockaddr_in&nbsp;ServerAddress;<br>sockaddr_in&nbsp;IncomingAddress;<br><b>sockaddr_in&nbsp;ClientAddress[8];</b><br>char&nbsp;Buffer[16];<br>int&nbsp;AddressLen&nbsp;=&nbsp;sizeof(IncomingAddress);</div><p style="padding-left:15px;">ClientAddress[8] is there so that we can store all the client addresses.  As they connect, we need to keep track of the clients so we can send messages back to all of them.  We'll look at this in the next step.</p><p style="padding-left:15px;">Notice that we are allowing for eight clients.  This can be expanded as you please. </p><hr><p class="subheader">2.  Have the main loop check each function to see if it is a knock.</p><p style="padding-left:15px;">This next bit is really just a bit of C++ code to check if the first bit is a 1.  If you don't remember from before, this is how the client tells the server that it is knocking, it sends a 1.  So that is the first task for this: see if the first byte is a 1.</p><div class="codebox" style="left:15px;">if(recvfrom(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>if(Buffer[0]&nbsp;==&nbsp;1)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;}</b><br><br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>}</div><p style="padding-left:15px;">The next thing to do would be to find a space that's available to store the client's address.  The solution is to iterate through the ClientAddress members until we find one that starts with a 0.</p><div class="codebox" style="left:15px;">if(recvfrom(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;1)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</b><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>}</div><p style="padding-left:15px;">We can find an empty ClientAddress member by checking the sin_family member of each.  Assuming we initialized the ClientAddress array, these will be zero if the member is unoccupied.</p><div class="codebox" style="left:15px;">if(recvfrom(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;1)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>if(!ClientAddress[i].sin_family)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</i><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>}</div><p style="padding-left:15px;">Up until this point, the client's address is stored inside IncomingAddress.  All we have to do now is copy this data into our available spot, and break the loop.</p><div class="codebox" style="left:15px;">if(recvfrom(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;1)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!ClientAddress[i].sin_family)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>ClientAddress[i]&nbsp;=&nbsp;IncomingAddress;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>}</div><p style="padding-left:15px;">There are possibly quite a few bugs here, but one major one we should cover is what happens when more than eight clients try to connect?  The answer is simple: ignore the message and wait for another one:</p><div class="codebox" style="left:15px;">if(recvfrom(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;1)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!ClientAddress[i].sin_family)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClientAddress[i]&nbsp;=&nbsp;IncomingAddress;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>continue;</b><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>}</div><p style="padding-left:15px;">This is a little less than cordial, but it'll do.  I say that because if we use this method, the client has no way of knowing why it couldn't connect.  We could send back a message saying the server is full, but we're building a simple chat program, and doing that could take some time. </p><hr><p class="subheader">3.  Broadcast any messages to all connected clients.</p><p style="padding-left:15px;">This step is fairly simple.  Whenever a message is received, we simply send it to every client in the ClientAddress array (assuming it isn't a blank address).</p><div class="codebox" style="left:15px;">Buffer[255]&nbsp;=&nbsp;'\0';&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Always&nbsp;end&nbsp;the&nbsp;packet&nbsp;with&nbsp;this<br>printf("Broadcasting:&nbsp;");<br>printf(Buffer);<br>printf("\n");<br>for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if(ClientAddress[i].sin_family)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendto(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;ClientAddress[i],&nbsp;sizeof(sockaddr));<br>}</div><p style="padding-left:15px;">The first thing to always do when receiving a packet is to place a '\0' at the end of it.  Not doing this can lead to dangerous security vulnerabilities.  I'll cover this in more detail in a later lesson.</p><p style="padding-left:15px;">Next, we print the data on the screen, prefixed with "Broadcasting: ".</p><p style="padding-left:15px;">Finally, we iterate through each member of the ClientAddress array and check to see if sin_family is 0.  If not, that means there is an address there, and we send the data to that address. </p><hr><p class="subheader">4.  Detect when a client is leaving, and clear his address from the array.</p><p style="padding-left:15px;">The last step is to detect any clients that may be leaving the server.  As discussed before, the client quits the program by sending a single space as the first character.  Therefore, all we have to do is wait for any messages that start with a space, find out who it came from, and set that address to 0.</p><p style="padding-left:15px;">We start by detecting a space in the first character.</p><div class="codebox" style="left:15px;">if(recvfrom(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;'&nbsp;')<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</div><p style="padding-left:15px;">Then we need to iterate through each ClientAddress until we find one that matches IncomingAddress.</p><div class="codebox" style="left:15px;">if(recvfrom(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;'&nbsp;')<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ClientAddress[i].sin_addr.s_addr&nbsp;==&nbsp;IncomingAddress.sin_addr.s_addr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</b><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</div><p style="padding-left:15px;">And when we find one, we clear that block of memory.  Doing this will keep future messages from being sent to this client, and will allow another client to join.</p><div class="codebox" style="left:15px;">if(recvfrom(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;'&nbsp;')<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ClientAddress[i].sin_addr.s_addr&nbsp;==&nbsp;IncomingAddress.sin_addr.s_addr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>ZeroMemory(&amp;ClientAddress[i],&nbsp;sizeof(sockaddr_in));</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</div><p style="padding-left:15px;">And that's all.</p><p style="padding-left:15px;">Now, this won't handle any time that the client quits the program by pressing the X button.  This is a topic for another lesson.  Let's look at what we have. </p><hr><p class="subheader">The Whole Server</p><p style="padding-left:15px;">If we put each of these four steps together with last lesson's server, we get a simple chat server that works well with the chat client.</p><div class="codebox" style="left:15px;">#define&nbsp;_WINSOCKAPI_<br>#include&nbsp;&lt;winsock2.h&gt;<br>#include&nbsp;&lt;stdio.h&gt;<br><br>#pragma&nbsp;comment(lib,&nbsp;"Ws2_32.lib")<br><br>#define&nbsp;SERVER_PORT&nbsp;17000<br><br>WSADATA&nbsp;Winsock;<br>SOCKET&nbsp;Socket;<br>sockaddr_in&nbsp;ServerAddress;<br>sockaddr_in&nbsp;IncomingAddress;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Contains&nbsp;the&nbsp;address&nbsp;of&nbsp;the&nbsp;sending&nbsp;client<br><b>sockaddr_in&nbsp;ClientAddress[8];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Stores&nbsp;the&nbsp;client's&nbsp;addresses</b><br>char&nbsp;Buffer[16];<br>int&nbsp;AddressLen&nbsp;=&nbsp;sizeof(IncomingAddress);<br><br>void&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;Winsock);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(LOBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2&nbsp;||&nbsp;HIBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Make&nbsp;the&nbsp;Socket<br>&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_DGRAM,&nbsp;IPPROTO_UDP);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input&nbsp;server&nbsp;information&nbsp;and&nbsp;bind&nbsp;it&nbsp;to&nbsp;the&nbsp;socket<br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;ServerAddress,&nbsp;sizeof(ServerAddress));<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_family&nbsp;=&nbsp;AF_INET;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_port&nbsp;=&nbsp;SERVER_PORT;<br>&nbsp;&nbsp;&nbsp;&nbsp;bind(Socket,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(ServerAddress));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;while(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(recvfrom(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;IncomingAddress,&nbsp;&amp;AddressLen))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//&nbsp;If&nbsp;the&nbsp;packet&nbsp;is&nbsp;a&nbsp;knock,&nbsp;add&nbsp;the&nbsp;client's&nbsp;address&nbsp;to&nbsp;ClientAddress<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!ClientAddress[i].sin_family)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClientAddress[i]&nbsp;=&nbsp;IncomingAddress;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Display&nbsp;the&nbsp;message&nbsp;and&nbsp;broadcast&nbsp;it&nbsp;to&nbsp;all&nbsp;active&nbsp;clients<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Buffer[255]&nbsp;=&nbsp;'\0';&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Always&nbsp;end&nbsp;the&nbsp;packet&nbsp;with&nbsp;this<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Broadcasting:&nbsp;");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(Buffer);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ClientAddress[i].sin_family)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendto(Socket,&nbsp;Buffer,&nbsp;256,&nbsp;0,&nbsp;(sockaddr*)&amp;ClientAddress[i],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(sockaddr));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;a&nbsp;client&nbsp;has&nbsp;quit,&nbsp;remove&nbsp;that&nbsp;client's&nbsp;address&nbsp;from&nbsp;ClientAddress<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Buffer[0]&nbsp;==&nbsp;'&nbsp;')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ClientAddress[i].sin_addr.s_addr&nbsp;==&nbsp;IncomingAddress.sin_addr.s_addr)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;ClientAddress[i],&nbsp;sizeof(sockaddr_in));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return;<br>}</div><p style="padding-left:15px;">If you run this code, you get this result.  Keep in mind that you can run multiple copies of the client by going into the folder where the client was built and running the exe file in the Debug folder.  You can run up to eight clients (though you can change this in the code).</p><center><img alt="The Simple Chat Client and Server" src="DirectXTutorial.com-4_files/3.png" height="514" width="641"><br><br>The Simple Chat Client and Server</center><p style="padding-left:15px;">And there you have it!  A chat program!  </p></div><div class="entryheader" style="position:relative;">Summary</div><div class="maintext" style="position: relative;"><p>Now with this program we are really getting somewhere.  We've covered the basics of how to transmit data across a network and how to track users.  Next, we'll apply these skills to an actual game and making game clients synchronize with each other using a game server.</p><p>Unfortunately, it's not ready just yet.  It should be very soon.</p><p>In the meantime, do the exercises and get ready:</p><p>1. Keep the client from receiving messages it itself sent. (see the "Uh...what?" message above) <br>2. Extend the number of clients that can join. <br>3. Change the quitting message so that it is 'exit' instead of a space key. <br>4. Make the server send a message to all clients whenever someone joins. <br>5. Now do it when someone leaves the server. <br>6. Make the client ask for a username and have the other clients display it before messages.</p><center><p>Next Lesson: Sending Game Data</p><p><a class="mainlink" href="http://www.directxtutorial.com/Lesson.aspx?lessonid=9-11-5">GO! GO! GO!</a></p></center></div><center><div class="copyright"> © 2006-2016 DirectXTutorial.com. All Rights Reserved. <a href="" onclick="RunLegal(); return false;" class="availablelink">Expand</a></div></center></div><script type="text/javascript">var _gaq = _gaq || [];_gaq.push(['_setAccount', 'UA-476839-2']);_gaq.push(['_trackPageview']);(function() {var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></body></html>