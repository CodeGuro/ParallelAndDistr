<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>DirectXTutorial.com</title><link href="DirectXTutorial.com-5_files/Layout.css" rel="Stylesheet" type="text/css"><link href="DirectXTutorial.com-5_files/Black.css" rel="Stylesheet" type="text/css"><script src="DirectXTutorial.com-5_files/ga.js" async="" type="text/javascript"></script><script type="text/javascript" src="DirectXTutorial.com-5_files/dxpages.js" language="javascript"></script></head><body><a href="http://www.directxtutorial.com/default.aspx"><img src="DirectXTutorial.com-5_files/HeadLogo.png" alt="DirectXTutorial.com"></a><div class="logoscript">The Ultimate DirectX Tutorial</div><div class="logout">Signed in as 'tukun2'<br><a class="mainlink" href="http://www.directxtutorial.com/changeprofile.aspx">Change Profile</a> - <a class="mainlink" href="http://www.directxtutorial.com/signout.aspx?retloc=lesson.aspx&amp;lessonid=9-11-5">Sign Out</a></div><div class="sidebar"><div class="sidepanel"><div><b>Navigation</b><br><br><a class="sidelink" href="http://www.directxtutorial.com/default.aspx">Home</a><br><a class="sidelink" href="http://www.directxtutorial.com/LessonList.aspx?listid=111">DirectX for Windows 8</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=112">DirectX 11.2</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=111">DirectX 11.1</a><br><a class="sidelink" href="http://www.directxtutorial.com/LegacyList.aspx">DirectX for Desktop</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=11">DirectX 11</a><br><a class="sidelinkin1" href="http://www.directxtutorial.com/LessonList.aspx?listid=9">DirectX 9</a><br><a class="sidelink" href="http://www.directxtutorial.com/lessonarticle.aspx?id=2">Useful Resources</a><br><a class="sidelink" href="http://www.directxtutorial.com/lessonarticle.aspx?id=1">About DirectXTutorial</a><br><a class="sidelink" href="http://www.directxtutorial.com/TPremium.aspx">DirectXTutorial Premium</a><br><a class="sidelink" href="http://www.directxtutorial.com/testimonials.aspx">Testimonials</a><br></div></div><br><div class="sidepanel"><div><b>Contact</b><br><br>Contact me here:<br><span style="font-size:11px;">Twitter: <a class="mainlink" href="https://twitter.com/#%21/dastopher">@dastopher</a><br>Email: chris@directxtutorial.com<br></span><br>Or leave me feedback:<br><span style="font-size:11px;"><a href="" class="mainlink" onclick="RunFeedback(); return false;">Quick Feedback</a></span><br></div></div><br></div><div class="titlebar">Lesson 5: Sending Game Data</div><div class="entrybox"><div class="navbar"><div class="prevbar"><a class="mainlink" href="http://www.directxtutorial.com/Lesson.aspx?lessonid=9-11-4">Previous</a></div></div><div class="entryheader" style="position:relative;">Lesson Overview</div><div class="maintext" style="position: relative;"><p>In
 this lesson we are going to take what we have learned of the UDP 
protocol and put to use by sending game data from one computer to 
another.</p><p>We'll create two programs.  The first will be the local 
client.  The other will be a remote "client", which will show the same 
thing as the first, but will receive its data over the network.  </p></div><div class="entryheader" style="position:relative;">Peer-to-Peer Model vs Client-Server Model</div><div class="maintext" style="position: relative;"><p>There
 are a number of ways to set up a network, but in gaming, there are 
typically only two: the peer-to-peer (P2P) model and the client-server 
model.  Let's find out what these are and when you would use which one.</p><p class="subheader">Peer-To-Peer Model</p><p style="padding-left:15px;">The
 peer-to-peer model is a way of connecting computers by having each 
computer establish an individual connection with each other computer on 
the network.  In such a setup there is no server, except if the 
computers aren't already aware of one another.</p><center><img alt="A Peer-To-Peer Network" src="DirectXTutorial.com-5_files/1.gif" height="321" width="381"><br><br>A Peer-To-Peer Network</center><p style="padding-left:15px;">The
 sole advantage to the peer-to-peer model is frequently out-weighed by 
its disadvantages.  The advantage is that each game does not require a 
separate server application to moderate it.  This, especially for 
less-financed games, can be the best way to go.</p><p style="padding-left:15px;">However,
 P2P connections require that each computer make a connection to each 
other computer, and so the connections increase progressively with each 
additional player.  While 3 players only requires 6 connections, 6 
players needs 30 connections, and 12 players needs 132 connections.</p><p style="padding-left:15px;">This
 can become worse with the fact that many game characters are controlled
 with the mouse, and sending (and receiving) mouse information to (and 
from) each other computer can be burdensome.</p><p style="padding-left:15px;">Another disadvantage is moderation.  With no centralized server, there is no easy way to detect cheaters.</p><p class="subheader">Client-Server Model</p><p style="padding-left:15px;">The
 client-server model is a way of setting up a network which involves a 
series of client computers connected to a server computer to moderate 
communications.  This is the model we have been using in this tutorial 
so far.</p><center><img alt="A Client-Server Network" src="DirectXTutorial.com-5_files/2.gif" height="334" width="629"><br><br>A Client-Server Network</center><p>The
 primary disadvantage to the client-server model is the need for 
servers.  This can easily by avoided by having the players create their 
own servers.  As you probably know, this is commonly done.</p><p>The 
advantages counter the disadvantages of the peer-to-peer model.  Each 
new player creates one new connection, allowing for a large number of 
players.  If you decide to host the game yourself, you get to decide the
 quality of the hardware, and thereby the quality of the game.</p><p>Another
 advantage is that a game server can more easily detect and handle 
cheaters than a peer-to-peer system can.  This is because the server can
 perform calculations, then broadcast the results to each client.  If a 
client were to perform the calculations, a hacker could alter the 
program to his advantage.  </p></div><div class="entryheader" style="position:relative;">Game Data vs Game Events</div><div class="maintext" style="position: relative;"><p>Once
 you've determined which network model you wish to use, you must then 
determine how game data will be sent from one player to another.</p><p>There
 are two usual ways to do this.  The first way to send game information 
is to constantly notify other players or the server of the player's 
current position, motion, actions, etc.  The second way to do this is to
 notify the other players only when specific events occur.</p><p class="subheader">Raw Game Data</p><p style="padding-left:15px;">In
 this first method, a player notifies all other players of his current 
state, typically including position, motion, and other properties.  Once
 the other players receive that information, they can update their 
various world matrices with the new data.</p><p style="padding-left:15px;">Of
 course, after a few milliseconds, that data is obsolete, and so needs 
to be resent.  This results in a continuous stream of data, from each 
player to each player.  This works best with the client-server model, as
 it can be slow to send many players continual information.</p><p class="subheader">Event Data</p><p style="padding-left:15px;">Event
 data is a bit more specialized than streamed data.  They are specific 
actions that occur in the game.  Event data is typically able to be sent
 once, then carried through on each computer with no further 
coordination.</p><p style="padding-left:15px;">An example of this 
shooting, or commanding a unit to a specific location.  Both of these 
activities take a limited amount of data up front, then all computers 
can perform the event.  If done right, none of the computers will 
execute the event any differently.</p><p style="padding-left:15px;">One 
disadvantage to this method is that all computers must wait for each 
other to acknowledge events.  This can cause a hold-up; when one 
computer lags, they all lag.  Event data requires all computers to be 
initially on the same page, so one computer falling behind causes 
activities to fall out of sync.</p><p class="subheader">When to Use Which</p><p style="padding-left:15px;">Some
 games use a combination of both of the above techniques.  However, most
 games stick with one or the other.  How you structure your networking 
will be entirely up to you, but I'll give you a few examples here so you
 can get an idea of what you want.</p><p style="padding-left:15px;">Strategy
 Games:  Many strategy games, such as Starcraft and the Warcraft series,
 use event data to coordinate activities between players.  If you've 
played multiplayer Starcraft you've surely seen the "Waiting for 
Players" dialog when one player stops responding.</p><p style="padding-left:15px;">Shooters:
  These games typically use raw data.  This is mainly because of the 
mouse.  When the player moves the mouse, the character's direction 
changes, and that change is shown on the other computers.  Because the 
mouse can be constantly moved, it doesn't make sense to send each and 
every mouse event to each computer.  It's better to simply stream 
regular updates on the player's position and movement.</p><p style="padding-left:15px;">RPGs:
  This depends entirely on the game being played, but most RPGs use raw 
data.  Because many of them are high-paced games, it can be a hassle to 
wait for other players.  </p></div><div class="entryheader" style="position:relative;">The Local App</div><div class="maintext" style="position: relative;"><p>In
 this example, we are going to focus on just sending data from one 
location to another, keeping the two in sync.  There will be a "local 
app" which will accept keyboard input to move a ball around the screen. 
 Then there will be a "remote app" which will accept network data and 
use it to move it's ball around.</p><p>Let's start with the local app.</p><hr><p>This
 app is a combination of two example programs we've already built.  We 
will need to render sprites, and we will need to send data over the 
network.  There are actually no new commands in this program.  The only 
thing that is new, is how it is done.</p><p>We'll create a separate 
function called init_winsock() to hold all the connection code, and a 
separate function called send_packet(), to send information about the 
ball.</p><p>Here's the init_winsock() function:</p><div class="codebox">void&nbsp;init_winsock()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;Winsock);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(LOBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2&nbsp;||&nbsp;HIBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;version<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Make&nbsp;the&nbsp;Socket<br>&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_DGRAM,&nbsp;IPPROTO_UDP);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input&nbsp;Server&nbsp;Information<br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;ServerAddress,&nbsp;sizeof(ServerAddress));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;struct<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;address&nbsp;family<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(SERVER_ADDRESS);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;IP&nbsp;address<br>&nbsp;&nbsp;&nbsp;&nbsp;ServerAddress.sin_port&nbsp;=&nbsp;SERVER_PORT;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;port<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Send&nbsp;a&nbsp;knock&nbsp;to&nbsp;the&nbsp;server<br>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;Knock&nbsp;=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;sendto(Socket,&nbsp;&amp;Knock,&nbsp;sizeof(char),&nbsp;0,&nbsp;(sockaddr*)&amp;ServerAddress,&nbsp;sizeof(sockaddr));<br>}</div><p>As you can see, nothing is really different, it's just what we had in main() last time.  Note that we didn't start a thread for receiving.  We'll get to that in a bit.</p><p>And here's the send_packet() function:</p><div class="codebox">void&nbsp;send_packet(BALL*&nbsp;data)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;sendto(Socket,&nbsp;(char*)data,&nbsp;sizeof(BALL),&nbsp;0,&nbsp;(sockaddr*)&amp;ServerAddress,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(sockaddr));<br>}</div><p>This is simple, except that there is a BALL in the parameter.  What is this BALL?  Well, it's anything you want, really.  It can be a struct and you can fill it with any data about the ball you want.  Here's what we will use in this demo:</p><div class="codebox">struct&nbsp;BALL{int&nbsp;x,&nbsp;y;};</div><p>Just a struct with the x and y coordinates of the ball.</p><p>Now let's add some input and some control to this ball.  Because it's simple, we'll just put it in the render_frame() function.</p><div class="codebox">BALL&nbsp;Ball;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;global<br><br>void&nbsp;render_frame(void)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>//&nbsp;move&nbsp;the&nbsp;ball<br>&nbsp;&nbsp;&nbsp;&nbsp;if(KEY_DOWN(VK_LEFT))&nbsp;Ball.x&nbsp;-=&nbsp;5;<br>&nbsp;&nbsp;&nbsp;&nbsp;if(KEY_DOWN(VK_RIGHT))&nbsp;Ball.x&nbsp;+=&nbsp;5;<br>&nbsp;&nbsp;&nbsp;&nbsp;if(KEY_DOWN(VK_UP))&nbsp;Ball.y&nbsp;-=&nbsp;5;<br>&nbsp;&nbsp;&nbsp;&nbsp;if(KEY_DOWN(VK_DOWN))&nbsp;Ball.y&nbsp;+=&nbsp;5;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;send&nbsp;the&nbsp;current&nbsp;information&nbsp;to&nbsp;the&nbsp;remote&nbsp;app<br>&nbsp;&nbsp;&nbsp;&nbsp;send_packet(&amp;Ball);</b><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;back&nbsp;buffer<br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;Clear(0,&nbsp;NULL,&nbsp;D3DCLEAR_TARGET,&nbsp;D3DCOLOR_XRGB(0,&nbsp;0,&nbsp;0),&nbsp;1.0f,&nbsp;0);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;BeginScene();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;begins&nbsp;the&nbsp;3D&nbsp;scene<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3dspt-&gt;Begin(D3DXSPRITE_ALPHABLEND);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;begin&nbsp;sprite&nbsp;drawing<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<b>//&nbsp;draw&nbsp;the&nbsp;ball<br>&nbsp;&nbsp;&nbsp;&nbsp;D3DXVECTOR3&nbsp;center(0.0f,&nbsp;0.0f,&nbsp;0.0f);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;center&nbsp;at&nbsp;the&nbsp;upper-left&nbsp;corner<br>&nbsp;&nbsp;&nbsp;&nbsp;D3DXVECTOR3&nbsp;position(Ball.x,&nbsp;Ball.y,&nbsp;0.0f);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;position&nbsp;the&nbsp;ball<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dspt-&gt;Draw(sprite,&nbsp;NULL,&nbsp;&amp;center,&nbsp;&amp;position,&nbsp;D3DCOLOR_XRGB(255,&nbsp;255,&nbsp;255));</b><br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3dspt-&gt;End();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;end&nbsp;sprite&nbsp;drawing<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;EndScene();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ends&nbsp;the&nbsp;3D&nbsp;scene<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;Present(NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL);<br>}</div><p>Now let's look at the whole program.</p><hr><p>Before you can run this, you'll need <a class="mainlink" target="_blank" href="http://www.directxtutorial.com/Images/Textures/Ball.png">Ball.png</a>.</p><div class="codebox">//&nbsp;include&nbsp;the&nbsp;header&nbsp;files<br>#define&nbsp;_WINSOCKAPI_&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;don't&nbsp;include&nbsp;Winsock.h<br>#include&nbsp;&lt;winsock2.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;WinSock&nbsp;header&nbsp;file<br>#include&nbsp;&lt;windowsx.h&gt;<br>#include&nbsp;&lt;d3d9.h&gt;<br>#include&nbsp;&lt;d3dx9.h&gt;<br><br>//&nbsp;include&nbsp;the&nbsp;library&nbsp;files<br>#pragma&nbsp;comment&nbsp;(lib,&nbsp;"d3d9.lib")<br>#pragma&nbsp;comment&nbsp;(lib,&nbsp;"d3dx9.lib")<br>#pragma&nbsp;comment&nbsp;(lib,&nbsp;"Ws2_32.lib")<br><br>//&nbsp;define&nbsp;the&nbsp;screen&nbsp;resolution&nbsp;and&nbsp;keyboard&nbsp;macros<br>#define&nbsp;SCREEN_WIDTH&nbsp;800<br>#define&nbsp;SCREEN_HEIGHT&nbsp;600<br>#define&nbsp;KEY_DOWN(vk_code)&nbsp;((GetAsyncKeyState(vk_code)&nbsp;&amp;&nbsp;0x8000)&nbsp;?&nbsp;1&nbsp;:&nbsp;0)<br>#define&nbsp;KEY_UP(vk_code)&nbsp;((GetAsyncKeyState(vk_code)&nbsp;&amp;&nbsp;0x8000)&nbsp;?&nbsp;0&nbsp;:&nbsp;1)<br>#define&nbsp;REMOTE_ADDRESS&nbsp;"192.168.1.100"<br>#define&nbsp;REMOTE_PORT&nbsp;17000<br><br>//&nbsp;a&nbsp;struct&nbsp;for&nbsp;the&nbsp;ball&nbsp;data<br>struct&nbsp;BALL{int&nbsp;x,&nbsp;y;};<br><br>//&nbsp;global&nbsp;declarations<br>LPDIRECT3D9&nbsp;d3d;<br>LPDIRECT3DDEVICE9&nbsp;d3ddev;<br>LPD3DXSPRITE&nbsp;d3dspt;<br>LPDIRECT3DTEXTURE9&nbsp;sprite;<br><br>WSADATA&nbsp;Winsock;<br>SOCKET&nbsp;Socket;<br>sockaddr_in&nbsp;RemoteAddress;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;address&nbsp;to&nbsp;send&nbsp;data&nbsp;to<br>int&nbsp;SizeInt&nbsp;=&nbsp;sizeof(RemoteAddress);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;address<br><br>BALL&nbsp;Ball;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;stores&nbsp;the&nbsp;local&nbsp;ball's&nbsp;position<br><br>//&nbsp;function&nbsp;prototypes<br>void&nbsp;initD3D(HWND&nbsp;hWnd);<br>void&nbsp;render_frame(void);<br>void&nbsp;cleanD3D(void);<br>void&nbsp;init_winsock(void);<br>void&nbsp;send_packet(BALL*&nbsp;data);<br><br>//&nbsp;the&nbsp;WindowProc&nbsp;function&nbsp;prototype<br>LRESULT&nbsp;CALLBACK&nbsp;WindowProc(HWND&nbsp;hWnd,&nbsp;UINT&nbsp;message,&nbsp;WPARAM&nbsp;wParam,&nbsp;LPARAM&nbsp;lParam);<br><br>//&nbsp;the&nbsp;entry&nbsp;point&nbsp;for&nbsp;any&nbsp;Windows&nbsp;program<br>int&nbsp;WINAPI&nbsp;WinMain(HINSTANCE&nbsp;hInstance,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HINSTANCE&nbsp;hPrevInstance,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPSTR&nbsp;lpCmdLine,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;nCmdShow)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;HWND&nbsp;hWnd;<br>&nbsp;&nbsp;&nbsp;&nbsp;WNDCLASSEX&nbsp;wc;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;wc,&nbsp;sizeof(WNDCLASSEX));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;wc.cbSize&nbsp;=&nbsp;sizeof(WNDCLASSEX);<br>&nbsp;&nbsp;&nbsp;&nbsp;wc.style&nbsp;=&nbsp;CS_HREDRAW&nbsp;|&nbsp;CS_VREDRAW;<br>&nbsp;&nbsp;&nbsp;&nbsp;wc.lpfnWndProc&nbsp;=&nbsp;WindowProc;<br>&nbsp;&nbsp;&nbsp;&nbsp;wc.hInstance&nbsp;=&nbsp;hInstance;<br>&nbsp;&nbsp;&nbsp;&nbsp;wc.hCursor&nbsp;=&nbsp;LoadCursor(NULL,&nbsp;IDC_ARROW);<br>&nbsp;&nbsp;&nbsp;&nbsp;wc.lpszClassName&nbsp;=&nbsp;L"WindowClass";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;RegisterClassEx(&amp;wc);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;hWnd&nbsp;=&nbsp;CreateWindowEx(NULL,&nbsp;L"WindowClass",&nbsp;L"Sender",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WS_OVERLAPPEDWINDOW,&nbsp;0,&nbsp;0,&nbsp;SCREEN_WIDTH,&nbsp;SCREEN_HEIGHT,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;NULL,&nbsp;hInstance,&nbsp;NULL);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ShowWindow(hWnd,&nbsp;nCmdShow);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;up&nbsp;and&nbsp;initialize&nbsp;Direct3D<br>&nbsp;&nbsp;&nbsp;&nbsp;initD3D(hWnd);<br>&nbsp;&nbsp;&nbsp;&nbsp;init_winsock();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;enter&nbsp;the&nbsp;main&nbsp;loop:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;MSG&nbsp;msg;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;while(TRUE)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(PeekMessage(&amp;msg,&nbsp;NULL,&nbsp;0,&nbsp;0,&nbsp;PM_REMOVE))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TranslateMessage(&amp;msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DispatchMessage(&amp;msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(msg.message&nbsp;==&nbsp;WM_QUIT)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;render_frame();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cleanD3D();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;msg.wParam;<br>}<br><br><br>//&nbsp;this&nbsp;is&nbsp;the&nbsp;main&nbsp;message&nbsp;handler&nbsp;for&nbsp;the&nbsp;program<br>LRESULT&nbsp;CALLBACK&nbsp;WindowProc(HWND&nbsp;hWnd,&nbsp;UINT&nbsp;message,&nbsp;WPARAM&nbsp;wParam,&nbsp;LPARAM&nbsp;lParam)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;switch(message)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PostQuitMessage(0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;DefWindowProc&nbsp;(hWnd,&nbsp;message,&nbsp;wParam,&nbsp;lParam);<br>}<br><br><br>//&nbsp;this&nbsp;function&nbsp;initializes&nbsp;and&nbsp;prepares&nbsp;Direct3D&nbsp;for&nbsp;use<br>void&nbsp;initD3D(HWND&nbsp;hWnd)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;d3d&nbsp;=&nbsp;Direct3DCreate9(D3D_SDK_VERSION);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;D3DPRESENT_PARAMETERS&nbsp;d3dpp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;d3dpp,&nbsp;sizeof(d3dpp));<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.Windowed&nbsp;=&nbsp;TRUE;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.SwapEffect&nbsp;=&nbsp;D3DSWAPEFFECT_DISCARD;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.hDeviceWindow&nbsp;=&nbsp;hWnd;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.BackBufferFormat&nbsp;=&nbsp;D3DFMT_X8R8G8B8;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.BackBufferWidth&nbsp;=&nbsp;SCREEN_WIDTH;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.BackBufferHeight&nbsp;=&nbsp;SCREEN_HEIGHT;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.EnableAutoDepthStencil&nbsp;=&nbsp;TRUE;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.AutoDepthStencilFormat&nbsp;=&nbsp;D3DFMT_D16;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;create&nbsp;a&nbsp;device&nbsp;class&nbsp;using&nbsp;this&nbsp;information&nbsp;and&nbsp;the&nbsp;info&nbsp;from&nbsp;the&nbsp;d3dpp&nbsp;stuct<br>&nbsp;&nbsp;&nbsp;&nbsp;d3d-&gt;CreateDevice(D3DADAPTER_DEFAULT,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3DDEVTYPE_HAL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hWnd,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3DCREATE_SOFTWARE_VERTEXPROCESSING,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;d3dpp,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;d3ddev);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;D3DXCreateSprite(d3ddev,&nbsp;&amp;d3dspt);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;create&nbsp;the&nbsp;sprite&nbsp;object<br>&nbsp;&nbsp;&nbsp;&nbsp;D3DXCreateTextureFromFile(d3ddev,&nbsp;L"Ball.png",&nbsp;&amp;sprite);<br>}<br><br><br>void&nbsp;render_frame(void)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;move&nbsp;the&nbsp;ball<br>&nbsp;&nbsp;&nbsp;&nbsp;if(KEY_DOWN(VK_LEFT))&nbsp;Ball.x&nbsp;-=&nbsp;5;<br>&nbsp;&nbsp;&nbsp;&nbsp;if(KEY_DOWN(VK_RIGHT))&nbsp;Ball.x&nbsp;+=&nbsp;5;<br>&nbsp;&nbsp;&nbsp;&nbsp;if(KEY_DOWN(VK_UP))&nbsp;Ball.y&nbsp;-=&nbsp;5;<br>&nbsp;&nbsp;&nbsp;&nbsp;if(KEY_DOWN(VK_DOWN))&nbsp;Ball.y&nbsp;+=&nbsp;5;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;send&nbsp;the&nbsp;current&nbsp;information&nbsp;to&nbsp;the&nbsp;remote&nbsp;app<br>&nbsp;&nbsp;&nbsp;&nbsp;send_packet(&amp;Ball);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;back&nbsp;buffer<br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;Clear(0,&nbsp;NULL,&nbsp;D3DCLEAR_TARGET,&nbsp;D3DCOLOR_XRGB(0,&nbsp;0,&nbsp;0),&nbsp;1.0f,&nbsp;0);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;BeginScene();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;begins&nbsp;the&nbsp;3D&nbsp;scene<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3dspt-&gt;Begin(D3DXSPRITE_ALPHABLEND);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;begin&nbsp;sprite&nbsp;drawing<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;draw&nbsp;the&nbsp;ball<br>&nbsp;&nbsp;&nbsp;&nbsp;D3DXVECTOR3&nbsp;center(0.0f,&nbsp;0.0f,&nbsp;0.0f);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;center&nbsp;at&nbsp;the&nbsp;upper-left&nbsp;corner<br>&nbsp;&nbsp;&nbsp;&nbsp;D3DXVECTOR3&nbsp;position(Ball.x,&nbsp;Ball.y,&nbsp;0.0f);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;position&nbsp;the&nbsp;ball<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dspt-&gt;Draw(sprite,&nbsp;NULL,&nbsp;&amp;center,&nbsp;&amp;position,&nbsp;D3DCOLOR_XRGB(255,&nbsp;255,&nbsp;255));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3dspt-&gt;End();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;end&nbsp;sprite&nbsp;drawing<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;EndScene();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ends&nbsp;the&nbsp;3D&nbsp;scene<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;Present(NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL);<br>}<br><br><br>//&nbsp;this&nbsp;is&nbsp;the&nbsp;function&nbsp;that&nbsp;cleans&nbsp;up&nbsp;Direct3D&nbsp;and&nbsp;COM<br>void&nbsp;cleanD3D(void)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;sprite-&gt;Release();<br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;Release();<br>&nbsp;&nbsp;&nbsp;&nbsp;d3d-&gt;Release();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br>}<br><br><br>void&nbsp;init_winsock()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;Winsock);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(LOBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2&nbsp;||&nbsp;HIBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;version<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Make&nbsp;the&nbsp;Socket<br>&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_DGRAM,&nbsp;IPPROTO_UDP);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input&nbsp;Receiver&nbsp;Information<br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;RemoteAddress,&nbsp;sizeof(RemoteAddress));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;struct<br>&nbsp;&nbsp;&nbsp;&nbsp;RemoteAddress.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;address&nbsp;family<br>&nbsp;&nbsp;&nbsp;&nbsp;RemoteAddress.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(REMOTE_ADDRESS);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;IP&nbsp;address<br>&nbsp;&nbsp;&nbsp;&nbsp;RemoteAddress.sin_port&nbsp;=&nbsp;REMOTE_PORT;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;port<br>}<br><br><br>void&nbsp;send_packet(BALL*&nbsp;data)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;sendto(Socket,&nbsp;(char*)data,&nbsp;sizeof(BALL),&nbsp;0,&nbsp;(sockaddr*)&amp;RemoteAddress,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(sockaddr));<br>}</div><p>This app will show a window with a ball in it.  The arrow keys will drive the ball around the screen.  The position of the ball will be sent to the targeted IP and port.</p><center><img alt="The Sender   " src="DirectXTutorial.com-5_files/3.png" height="478" width="638"><br><br>The Sender   </center></div><div class="entryheader" style="position:relative;">The Remote App</div><div class="maintext" style="position: relative;"><p>Now let's build the receiving end of this program.</p><p>This program is actually quite simple.  We'll copy the code from the sending program, and modify it to receive instead of send.  There really is nothing new.</p><p>First we have to bind the socket so that we can receive incoming data.</p><div class="codebox">void&nbsp;init_winsock()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input&nbsp;Sender&nbsp;Information<br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;RemoteAddress,&nbsp;sizeof(RemoteAddress));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;struct<br>&nbsp;&nbsp;&nbsp;&nbsp;RemoteAddress.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;address&nbsp;family<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>//&nbsp;RemoteAddress.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(REMOTE_ADDRESS);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;don't&nbsp;need&nbsp;this</b><br>&nbsp;&nbsp;&nbsp;&nbsp;RemoteAddress.sin_port&nbsp;=&nbsp;REMOTE_PORT;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;port<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>bind(Socket,&nbsp;(sockaddr*)&amp;RemoteAddress,&nbsp;sizeof(RemoteAddress));</b><br>}</div><p>And of course, we have to add and start the receiving thread.</p><div class="codebox">DWORD&nbsp;WINAPI&nbsp;RecvThread(LPVOID&nbsp;Whatever)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;while(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BALL&nbsp;Recv;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvfrom(Socket,&nbsp;(char*)&amp;Recv,&nbsp;sizeof(BALL),&nbsp;0,&nbsp;(sockaddr*)&amp;RemoteAddress,&nbsp;&amp;SizeInt);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ball&nbsp;=&nbsp;Recv;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</div><p>And we'll start the thread in the init_winsock() function.</p><div class="codebox">void&nbsp;init_winsock()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input&nbsp;Sender&nbsp;Information<br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;RemoteAddress,&nbsp;sizeof(RemoteAddress));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;struct<br>&nbsp;&nbsp;&nbsp;&nbsp;RemoteAddress.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;address&nbsp;family<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;RemoteAddress.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(REMOTE_ADDRESS);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;don't&nbsp;need&nbsp;this<br>&nbsp;&nbsp;&nbsp;&nbsp;RemoteAddress.sin_port&nbsp;=&nbsp;REMOTE_PORT;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;port<br>&nbsp;&nbsp;&nbsp;&nbsp;bind(Socket,&nbsp;(sockaddr*)&amp;RemoteAddress,&nbsp;sizeof(RemoteAddress));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<b>//&nbsp;Start&nbsp;the&nbsp;receive&nbsp;thread<br>&nbsp;&nbsp;&nbsp;&nbsp;CreateThread(NULL,&nbsp;0,&nbsp;RecvThread,&nbsp;NULL,&nbsp;0,&nbsp;NULL);</b><br>}</div><p>And the full code:</p><div class="codebox">//&nbsp;include&nbsp;the&nbsp;header&nbsp;files<br>#define&nbsp;_WINSOCKAPI_&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;don't&nbsp;include&nbsp;Winsock.h<br>#include&nbsp;&lt;winsock2.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;WinSock&nbsp;header&nbsp;file<br>#include&nbsp;&lt;windowsx.h&gt;<br>#include&nbsp;&lt;d3d9.h&gt;<br>#include&nbsp;&lt;d3dx9.h&gt;<br><br>//&nbsp;include&nbsp;the&nbsp;library&nbsp;files<br>#pragma&nbsp;comment&nbsp;(lib,&nbsp;"d3d9.lib")<br>#pragma&nbsp;comment&nbsp;(lib,&nbsp;"d3dx9.lib")<br>#pragma&nbsp;comment&nbsp;(lib,&nbsp;"Ws2_32.lib")<br><br>//&nbsp;define&nbsp;the&nbsp;screen&nbsp;resolution&nbsp;and&nbsp;keyboard&nbsp;macros<br>#define&nbsp;SCREEN_WIDTH&nbsp;800<br>#define&nbsp;SCREEN_HEIGHT&nbsp;600<br>#define&nbsp;KEY_DOWN(vk_code)&nbsp;((GetAsyncKeyState(vk_code)&nbsp;&amp;&nbsp;0x8000)&nbsp;?&nbsp;1&nbsp;:&nbsp;0)<br>#define&nbsp;KEY_UP(vk_code)&nbsp;((GetAsyncKeyState(vk_code)&nbsp;&amp;&nbsp;0x8000)&nbsp;?&nbsp;0&nbsp;:&nbsp;1)<br>#define&nbsp;REMOTE_ADDRESS&nbsp;"192.168.1.100"<br>#define&nbsp;REMOTE_PORT&nbsp;17000<br><br>//&nbsp;a&nbsp;struct&nbsp;for&nbsp;the&nbsp;ball&nbsp;data<br>struct&nbsp;BALL{int&nbsp;x,&nbsp;y;};<br><br>//&nbsp;global&nbsp;declarations<br>LPDIRECT3D9&nbsp;d3d;<br>LPDIRECT3DDEVICE9&nbsp;d3ddev;<br>LPD3DXSPRITE&nbsp;d3dspt;<br>LPDIRECT3DTEXTURE9&nbsp;sprite;<br><br>WSADATA&nbsp;Winsock;<br>SOCKET&nbsp;Socket;<br>sockaddr_in&nbsp;RemoteAddress;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;address&nbsp;to&nbsp;send&nbsp;data&nbsp;to<br>int&nbsp;SizeInt&nbsp;=&nbsp;sizeof(RemoteAddress);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;address<br><br>BALL&nbsp;Ball;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;stores&nbsp;the&nbsp;local&nbsp;ball's&nbsp;position<br><br>//&nbsp;function&nbsp;prototypes<br>void&nbsp;initD3D(HWND&nbsp;hWnd);<br>void&nbsp;render_frame(void);<br>void&nbsp;cleanD3D(void);<br>void&nbsp;init_winsock(void);<br><b>DWORD&nbsp;WINAPI&nbsp;RecvThread(LPVOID&nbsp;Whatever);</b><br><br>//&nbsp;the&nbsp;WindowProc&nbsp;function&nbsp;prototype<br>LRESULT&nbsp;CALLBACK&nbsp;WindowProc(HWND&nbsp;hWnd,&nbsp;UINT&nbsp;message,&nbsp;WPARAM&nbsp;wParam,&nbsp;LPARAM&nbsp;lParam);<br><br>//&nbsp;the&nbsp;entry&nbsp;point&nbsp;for&nbsp;any&nbsp;Windows&nbsp;program<br>int&nbsp;WINAPI&nbsp;WinMain(HINSTANCE&nbsp;hInstance,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HINSTANCE&nbsp;hPrevInstance,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPSTR&nbsp;lpCmdLine,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;nCmdShow)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;HWND&nbsp;hWnd;<br>&nbsp;&nbsp;&nbsp;&nbsp;WNDCLASSEX&nbsp;wc;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;wc,&nbsp;sizeof(WNDCLASSEX));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;wc.cbSize&nbsp;=&nbsp;sizeof(WNDCLASSEX);<br>&nbsp;&nbsp;&nbsp;&nbsp;wc.style&nbsp;=&nbsp;CS_HREDRAW&nbsp;|&nbsp;CS_VREDRAW;<br>&nbsp;&nbsp;&nbsp;&nbsp;wc.lpfnWndProc&nbsp;=&nbsp;WindowProc;<br>&nbsp;&nbsp;&nbsp;&nbsp;wc.hInstance&nbsp;=&nbsp;hInstance;<br>&nbsp;&nbsp;&nbsp;&nbsp;wc.hCursor&nbsp;=&nbsp;LoadCursor(NULL,&nbsp;IDC_ARROW);<br>&nbsp;&nbsp;&nbsp;&nbsp;wc.lpszClassName&nbsp;=&nbsp;L"WindowClass";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;RegisterClassEx(&amp;wc);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;hWnd&nbsp;=&nbsp;CreateWindowEx(NULL,&nbsp;L"WindowClass",&nbsp;L"Receiver",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WS_OVERLAPPEDWINDOW,&nbsp;0,&nbsp;0,&nbsp;SCREEN_WIDTH,&nbsp;SCREEN_HEIGHT,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;NULL,&nbsp;hInstance,&nbsp;NULL);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ShowWindow(hWnd,&nbsp;nCmdShow);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;up&nbsp;and&nbsp;initialize&nbsp;Direct3D<br>&nbsp;&nbsp;&nbsp;&nbsp;initD3D(hWnd);<br>&nbsp;&nbsp;&nbsp;&nbsp;init_winsock();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;enter&nbsp;the&nbsp;main&nbsp;loop:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;MSG&nbsp;msg;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;while(TRUE)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(PeekMessage(&amp;msg,&nbsp;NULL,&nbsp;0,&nbsp;0,&nbsp;PM_REMOVE))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TranslateMessage(&amp;msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DispatchMessage(&amp;msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(msg.message&nbsp;==&nbsp;WM_QUIT)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;render_frame();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cleanD3D();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;msg.wParam;<br>}<br><br><br>//&nbsp;this&nbsp;is&nbsp;the&nbsp;main&nbsp;message&nbsp;handler&nbsp;for&nbsp;the&nbsp;program<br>LRESULT&nbsp;CALLBACK&nbsp;WindowProc(HWND&nbsp;hWnd,&nbsp;UINT&nbsp;message,&nbsp;WPARAM&nbsp;wParam,&nbsp;LPARAM&nbsp;lParam)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;switch(message)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PostQuitMessage(0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;DefWindowProc&nbsp;(hWnd,&nbsp;message,&nbsp;wParam,&nbsp;lParam);<br>}<br><br><br>//&nbsp;this&nbsp;function&nbsp;initializes&nbsp;and&nbsp;prepares&nbsp;Direct3D&nbsp;for&nbsp;use<br>void&nbsp;initD3D(HWND&nbsp;hWnd)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;d3d&nbsp;=&nbsp;Direct3DCreate9(D3D_SDK_VERSION);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;D3DPRESENT_PARAMETERS&nbsp;d3dpp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;d3dpp,&nbsp;sizeof(d3dpp));<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.Windowed&nbsp;=&nbsp;TRUE;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.SwapEffect&nbsp;=&nbsp;D3DSWAPEFFECT_DISCARD;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.hDeviceWindow&nbsp;=&nbsp;hWnd;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.BackBufferFormat&nbsp;=&nbsp;D3DFMT_X8R8G8B8;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.BackBufferWidth&nbsp;=&nbsp;SCREEN_WIDTH;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.BackBufferHeight&nbsp;=&nbsp;SCREEN_HEIGHT;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.EnableAutoDepthStencil&nbsp;=&nbsp;TRUE;<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dpp.AutoDepthStencilFormat&nbsp;=&nbsp;D3DFMT_D16;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;create&nbsp;a&nbsp;device&nbsp;class&nbsp;using&nbsp;this&nbsp;information&nbsp;and&nbsp;the&nbsp;info&nbsp;from&nbsp;the&nbsp;d3dpp&nbsp;stuct<br>&nbsp;&nbsp;&nbsp;&nbsp;d3d-&gt;CreateDevice(D3DADAPTER_DEFAULT,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3DDEVTYPE_HAL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hWnd,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D3DCREATE_SOFTWARE_VERTEXPROCESSING,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;d3dpp,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;d3ddev);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;D3DXCreateSprite(d3ddev,&nbsp;&amp;d3dspt);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;create&nbsp;the&nbsp;sprite&nbsp;object<br>&nbsp;&nbsp;&nbsp;&nbsp;D3DXCreateTextureFromFile(d3ddev,&nbsp;L"Ball.png",&nbsp;&amp;sprite);<br>}<br><br><br>void&nbsp;render_frame(void)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;back&nbsp;buffer<br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;Clear(0,&nbsp;NULL,&nbsp;D3DCLEAR_TARGET,&nbsp;D3DCOLOR_XRGB(0,&nbsp;0,&nbsp;0),&nbsp;1.0f,&nbsp;0);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;BeginScene();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;begins&nbsp;the&nbsp;3D&nbsp;scene<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3dspt-&gt;Begin(D3DXSPRITE_ALPHABLEND);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;begin&nbsp;sprite&nbsp;drawing<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;draw&nbsp;the&nbsp;ball<br>&nbsp;&nbsp;&nbsp;&nbsp;D3DXVECTOR3&nbsp;center(0.0f,&nbsp;0.0f,&nbsp;0.0f);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;center&nbsp;at&nbsp;the&nbsp;upper-left&nbsp;corner<br>&nbsp;&nbsp;&nbsp;&nbsp;D3DXVECTOR3&nbsp;position(Ball.x,&nbsp;Ball.y,&nbsp;0.0f);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;position&nbsp;the&nbsp;ball<br>&nbsp;&nbsp;&nbsp;&nbsp;d3dspt-&gt;Draw(sprite,&nbsp;NULL,&nbsp;&amp;center,&nbsp;&amp;position,&nbsp;D3DCOLOR_XRGB(255,&nbsp;255,&nbsp;255));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3dspt-&gt;End();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;end&nbsp;sprite&nbsp;drawing<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;EndScene();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ends&nbsp;the&nbsp;3D&nbsp;scene<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;Present(NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL);<br>}<br><br><br>//&nbsp;this&nbsp;is&nbsp;the&nbsp;function&nbsp;that&nbsp;cleans&nbsp;up&nbsp;Direct3D&nbsp;and&nbsp;COM<br>void&nbsp;cleanD3D(void)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;sprite-&gt;Release();<br>&nbsp;&nbsp;&nbsp;&nbsp;d3ddev-&gt;Release();<br>&nbsp;&nbsp;&nbsp;&nbsp;d3d-&gt;Release();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br>}<br><br><br>void&nbsp;init_winsock()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAStartup(MAKEWORD(2,&nbsp;2),&nbsp;&amp;Winsock);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(LOBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2&nbsp;||&nbsp;HIBYTE(Winsock.wVersion)&nbsp;!=&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;version<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WSACleanup();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Make&nbsp;the&nbsp;Socket<br>&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_DGRAM,&nbsp;IPPROTO_UDP);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Input&nbsp;Receiver&nbsp;Information<br>&nbsp;&nbsp;&nbsp;&nbsp;ZeroMemory(&amp;RemoteAddress,&nbsp;sizeof(RemoteAddress));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;clear&nbsp;the&nbsp;struct<br>&nbsp;&nbsp;&nbsp;&nbsp;RemoteAddress.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;address&nbsp;family<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>//&nbsp;RemoteAddress.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(REMOTE_ADDRESS);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;don't&nbsp;need&nbsp;this</b><br>&nbsp;&nbsp;&nbsp;&nbsp;RemoteAddress.sin_port&nbsp;=&nbsp;REMOTE_PORT;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;set&nbsp;the&nbsp;port<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>bind(Socket,&nbsp;(sockaddr*)&amp;RemoteAddress,&nbsp;sizeof(RemoteAddress));</b><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<b>//&nbsp;Start&nbsp;the&nbsp;receive&nbsp;thread<br>&nbsp;&nbsp;&nbsp;&nbsp;CreateThread(NULL,&nbsp;0,&nbsp;RecvThread,&nbsp;NULL,&nbsp;0,&nbsp;NULL);</b><br>}<br><br><br><b>DWORD&nbsp;WINAPI&nbsp;RecvThread(LPVOID&nbsp;Whatever)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;while(true)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BALL&nbsp;Recv;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvfrom(Socket,&nbsp;(char*)&amp;Recv,&nbsp;sizeof(BALL),&nbsp;0,&nbsp;(sockaddr*)&amp;RemoteAddress,&nbsp;&amp;SizeInt);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ball&nbsp;=&nbsp;Recv;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</b></div><p>The screenshot for this program is exactly the same as the client (except that the window title is "Receiver" instead of "Sender").</p><p>Try getting this code up and running, then do the exercises below.  </p></div><div class="entryheader" style="position:relative;">Summary</div><div class="maintext" style="position: relative;"><p>At this point, all we can do is send basic data from one computer to another.  This is a good point to stop, practice what you've learned, then move on to more advanced data transfer.</p><p>Do these exercises before moving on.</p><p>1.  Have the receiver run on a different computer than the sender. <br>2.  Add another ball to both programs, and have the receiver control it. <br>3.  Challenge: Add a third ball, controlled by a third computer.</p><center><p>Next Lesson: Coming Soon</p></center></div><center><div class="copyright"> © 2006-2016 DirectXTutorial.com. All Rights Reserved. <a href="" onclick="RunLegal(); return false;" class="availablelink">Expand</a></div></center></div><script type="text/javascript">var _gaq = _gaq || [];_gaq.push(['_setAccount', 'UA-476839-2']);_gaq.push(['_trackPageview']);(function() {var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></body></html>